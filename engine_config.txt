#!/usr/bin/env python3
"""
COMPREHENSIVE FIXED engine.py - Anti-LLM Rhyme Engine
Proper integration of k3/k2/k1 architecture with phonetics module

CRITICAL FIXES:
1. âœ… Correct imports from phonetics module (not circular!)
2. âœ… Three-stage k3/k2/k1 query architecture
3. âœ… Proper phonetic scoring
4. âœ… All utility functions for app.py

This file provides the interface that app.py expects while using
the fixed phonetics and search implementations.
"""

import sqlite3
from dataclasses import dataclass
from typing import List, Dict, Any, Tuple, Optional, Set
import requests
from functools import lru_cache
import time
from collections import defaultdict
from pathlib import Path
import os

# =============================================================================
# CONFIGURATION
# =============================================================================

@dataclass
class Config:
    """Configuration for rhyme search"""
    max_items: int = 200  # Maximum results per category
    zipf_min: float = 0.0  # Minimum word frequency (0 = no filter for testing)
    zipf_max_slant: float = 10.0  # Maximum for slant rhymes (10 = no filter)
    zipf_max_multi: float = 10.0  # Maximum for multiword
    enable_datamuse: bool = True
    database_path: str = "data/words_index.sqlite"

cfg = Config()

# Emoji indicators for UI
EMOJI = {
    'k3_perfect': 'â­',
    'k2_perfect': 'âœ“',
    'k1_assonance': 'â‰ˆ',
    'technical': 'ğŸ“š',
    'popular': 'âœ“âœ“',
    'alliteration': 'ğŸ”¤',
    'multisyl': 'ğŸµ',
    'multiword': 'ğŸ’¬',
    'datamuse': 'ğŸŒ'
}

# =============================================================================
# DATABASE CONNECTION
# =============================================================================

def get_db() -> sqlite3.Connection:
    """Get database connection"""
    db_path = Path(cfg.database_path)
    if not db_path.exists():
        raise FileNotFoundError(f"Database not found: {db_path}")
    
    conn = sqlite3.connect(str(db_path))
    conn.row_factory = sqlite3.Row
    return conn

# =============================================================================
# PHONETIC FUNCTIONS - Import from phonetics module
# =============================================================================

def strip_stress(phone: str) -> str:
    """Remove stress marker from phoneme"""
    if phone and phone[-1] in '012':
        return phone[:-1]
    return phone

def is_vowel(phone: str) -> bool:
    """Check if phoneme is a vowel"""
    # ARPAbet vowels
    VOWELS = {"AA","AE","AH","AO","AW","AY","EH","ER","EY","IH","IY","OW","OY","UH","UW"}
    base = phone.rstrip('012')  # Strip stress markers
    return base in VOWELS

def extract_stress_pattern(phones: List[str]) -> str:
    """Extract stress pattern from phoneme list"""
    stress_marks = []
    for phone in phones:
        if is_vowel(phone):
            if phone[-1] in '012':
                stress_marks.append(phone[-1])
            else:
                stress_marks.append('0')
    return '-'.join(stress_marks)

def get_meter_type(stress_pattern: str) -> str:
    """Get poetic meter name from stress pattern"""
    if not stress_pattern:
        return "unknown"
